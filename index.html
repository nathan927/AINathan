<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°æ™ºAIèŠå¤©å¤¥ä¼´ - Webç‰ˆæœ¬</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .container {
            width: 90%;
            max-width: 400px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
        }

        .header {
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            padding: 20px;
            text-align: center;
            color: white;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .status {
            font-size: 14px;
            opacity: 0.9;
        }

        .chat-area {
            height: 400px;
            overflow-y: auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
        }

        .message {
            margin-bottom: 15px;
            padding: 12px 16px;
            border-radius: 18px;
            max-width: 80%;
            word-wrap: break-word;
            animation: fadeIn 0.3s ease-in;
        }

        .user-message {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 6px;
        }

        .ai-message {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border-bottom-left-radius: 6px;
        }

        .controls {
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .input-group input {
            flex: 1;
            padding: 12px 16px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            outline: none;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .voice-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .voice-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .record-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .record-btn.recording {
            background: linear-gradient(45deg, #ee5a24, #ff6b6b);
            animation: pulse 1s infinite;
        }

        .speak-btn {
            background: linear-gradient(45deg, #00d2d3, #54a0ff);
            color: white;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .settings {
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .settings select {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            outline: none;
            margin-bottom: 10px;
        }

        .token-config {
            display: flex;
            gap: 4%;
            margin-bottom: 10px;
        }

        .connection-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 8px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.9);
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff6b6b;
            animation: blink 2s infinite;
        }

        .status-indicator.connected {
            background: #00d2d3;
            animation: none;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .welcome-message {
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            font-style: italic;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¤– å°æ™ºAI</h1>
            <div class="status" id="status">æº–å‚™å°±ç·’</div>
        </div>

        <div class="chat-area" id="chatArea">
            <div class="welcome-message">
                ğŸ‘‹ æ‚¨å¥½ï¼æˆ‘æ˜¯å°æ™ºï¼Œæ‚¨çš„AIèŠå¤©å¤¥ä¼´<br>
                å¯ä»¥å’Œæˆ‘èªéŸ³å°è©±æˆ–æ–‡å­—èŠå¤©å–”ï¼
            </div>
        </div>

        <div class="controls">
            <div class="input-group">
                <input type="text" id="messageInput" placeholder="è¼¸å…¥è¨Šæ¯..." />
                <button class="btn" onclick="sendMessage()">å‚³é€</button>
            </div>

            <div class="voice-controls">
                <button class="voice-btn record-btn" id="recordBtn" onclick="toggleRecording()">ğŸ¤</button>
                <button class="voice-btn speak-btn" onclick="speakLastMessage()">ğŸ”Š</button>
            </div>
        </div>

        <div class="settings">
            <select id="languageSelect" onchange="changeLanguage()">
                <option value="zh-TW">ç¹é«”ä¸­æ–‡</option>
                <option value="zh-CN">ç®€ä½“ä¸­æ–‡</option>
                <option value="en-US">English</option>
                <option value="ja-JP">æ—¥æœ¬èª</option>
                <option value="ko-KR">í•œêµ­ì–´</option>
            </select>
            
            <div class="token-config">
                <button class="btn" onclick="showTokenConfig()" style="width: 48%; font-size: 12px;">é…ç½®Token</button>
                <button class="btn" onclick="clearToken()" style="width: 48%; font-size: 12px;">æ¸…é™¤Token</button>
            </div>
            
            <div class="connection-status">
                <div class="status-indicator" id="statusIndicator"></div>
                <span id="connectionText">æ­£åœ¨é€£ç·š...</span>
                <button class="btn" style="margin-left: auto; padding: 4px 12px; font-size: 12px;" onclick="reconnect()">é‡æ–°é€£ç·š</button>
            </div>
        </div>
    </div>

    <script>
        // PLACEHOLDER_FOR_CONFIG
        
        let isRecording = false;
        let recognition = null;
        let synthesis = window.speechSynthesis;
        let currentLanguage = 'zh-TW';
        let lastAiMessage = '';
        let websocket = null;
        let isConnected = false;
        let messageId = 1;

        // è·å–MCPæ¥å…¥ç‚¹åœ°å€
        function getMCPEndpoint() {
            // æ–¹æ³•1: ä»ç¯å¢ƒå˜é‡è·å– (é€‚ç”¨äºæ„å»ºæ—¶æ³¨å…¥)
            if (typeof process !== 'undefined' && process.env && process.env.XIAOZHI_TOKEN) {
                return `wss://api.xiaozhi.me/mcp/?token=${process.env.XIAOZHI_TOKEN}`;
            }
            
            // æ–¹æ³•2: ä»å…¨å±€é…ç½®è·å– (é€‚ç”¨äºGitHub Actionsæ„å»º)
            if (typeof window !== 'undefined' && window.XIAOZHI_CONFIG && window.XIAOZHI_CONFIG.token) {
                return `wss://api.xiaozhi.me/mcp/?token=${window.XIAOZHI_CONFIG.token}`;
            }
            
            // æ–¹æ³•3: ä»æœ¬åœ°å­˜å‚¨è·å– (ç”¨æˆ·é…ç½®)
            if (typeof localStorage !== 'undefined') {
                const userToken = localStorage.getItem('xiaozhi_token');
                if (userToken) {
                    return `wss://api.xiaozhi.me/mcp/?token=${userToken}`;
                }
            }
            
            // æ–¹æ³•4: æç¤ºç”¨æˆ·é…ç½®
            return null;
        }

        // æ˜¾ç¤ºTokené…ç½®ç•Œé¢
        function showTokenConfig() {
            const currentToken = localStorage.getItem('xiaozhi_token');
            const message = currentToken ? 
                'ç›®å‰å·²é…ç½®Tokenã€‚\n\nè«‹è¼¸å…¥æ–°çš„å°æ™ºAI Tokenï¼ˆç•™ç©ºå–æ¶ˆï¼‰:' : 
                'è«‹è¼¸å…¥æ‚¨çš„å°æ™ºAI Token:\n\næ‚¨å¯ä»¥åœ¨ https://xiaozhi.me è¨»å†Šä¸¦ç²å–å…è²»Token';
                
            const tokenInput = prompt(message);
            if (tokenInput && tokenInput.trim()) {
                localStorage.setItem('xiaozhi_token', tokenInput.trim());
                addMessage('âœ… Tokenå·²æ›´æ–°ï¼Œæ­£åœ¨é‡æ–°é€£ç·š...', 'ai');
                location.reload(); // é‡æ–°åŠ è½½é¡µé¢
            }
        }

        // æ¸…é™¤Token
        function clearToken() {
            if (confirm('ç¢ºå®šè¦æ¸…é™¤Tokenå—ï¼Ÿæ¸…é™¤å¾Œéœ€è¦é‡æ–°é…ç½®æ‰èƒ½ä½¿ç”¨ã€‚')) {
                localStorage.removeItem('xiaozhi_token');
                if (websocket) {
                    websocket.close();
                }
                isConnected = false;
                updateStatus('âŒ Tokenå·²æ¸…é™¤');
                addMessage('Tokenå·²æ¸…é™¤ã€‚è«‹é‡æ–°é…ç½®Tokenå¾Œä½¿ç”¨ã€‚', 'ai');
            }
        }

        // åˆå§‹åŒ–WebSocketè¿æ¥
        function initWebSocket() {
            // æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆçš„MCPç«¯ç‚¹
            const MCP_ENDPOINT = getMCPEndpoint();
            if (!MCP_ENDPOINT) {
                updateStatus('âŒ éœ€è¦é…ç½®Token');
                addMessage('ğŸ‘‹ æ­¡è¿ä½¿ç”¨å°æ™ºAIï¼\n\nè«‹é»æ“Šä¸‹æ–¹ã€Œé…ç½®Tokenã€æŒ‰éˆ•ä¾†è¨­å®šæ‚¨çš„API Tokenã€‚\n\næ‚¨å¯ä»¥åœ¨ https://xiaozhi.me è¨»å†Šä¸¦ç²å–å…è²»çš„Tokenã€‚', 'ai');
                return;
            }

            try {
                updateStatus('æ­£åœ¨é€£ç·šåˆ°å°æ™ºä¼ºæœå™¨...');
                websocket = new WebSocket(MCP_ENDPOINT);

                websocket.onopen = function(event) {
                    isConnected = true;
                    updateStatus('âœ… å·²é€£ç·šåˆ°å°æ™ºAI');
                    console.log('WebSocketé€£ç·šå·²å»ºç«‹');
                    
                    // æ·»åŠ è¿æ¥æˆåŠŸæ¶ˆæ¯
                    addMessage('ğŸ‰ é€£ç·šæˆåŠŸï¼æˆ‘æ˜¯å°æ™ºï¼Œå¾ˆé«˜èˆˆç‚ºæ‚¨æœå‹™ï¼', 'ai');
                    
                    // å‘é€åˆå§‹åŒ–æ¶ˆæ¯
                    sendMCPMessage({
                        jsonrpc: "2.0",
                        id: messageId++,
                        method: "initialize",
                        params: {
                            protocolVersion: "2024-11-05",
                            capabilities: {
                                roots: {
                                    listChanged: true
                                },
                                sampling: {}
                            },
                            clientInfo: {
                                name: "xiaozhi-web-client",
                                version: "1.0.0"
                            }
                        }
                    });
                };

                websocket.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('æ”¶åˆ°è¨Šæ¯:', data);
                        handleMCPMessage(data);
                    } catch (error) {
                        console.error('è§£æè¨Šæ¯å¤±æ•—:', error);
                    }
                };

                websocket.onclose = function(event) {
                    isConnected = false;
                    updateStatus('âŒ é€£ç·šå·²ä¸­æ–·');
                    console.log('WebSocketé€£ç·šå·²é—œé–‰:', event);
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯tokené—®é¢˜
                    if (event.code === 1008 || event.code === 1002) {
                        addMessage('âŒ Tokenå¯èƒ½å·²éæœŸæˆ–ç„¡æ•ˆï¼Œè«‹é‡æ–°é…ç½®ã€‚', 'ai');
                        localStorage.removeItem('xiaozhi_token');
                    } else {
                        // å°è¯•é‡è¿
                        setTimeout(() => {
                            if (!isConnected) {
                                const currentEndpoint = getMCPEndpoint();
                                if (currentEndpoint) {
                                    initWebSocket();
                                }
                            }
                        }, 3000);
                    }
                };

                websocket.onerror = function(error) {
                    isConnected = false;
                    updateStatus('âŒ é€£ç·šéŒ¯èª¤');
                    console.error('WebSocketéŒ¯èª¤:', error);
                };

            } catch (error) {
                console.error('WebSocketåˆå§‹åŒ–å¤±æ•—:', error);
                updateStatus('âŒ é€£ç·šå¤±æ•—');
            }
        }

        // å‘é€MCPæ¶ˆæ¯
        function sendMCPMessage(message) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send(JSON.stringify(message));
                console.log('å‚³é€è¨Šæ¯:', message);
            } else {
                console.error('WebSocketæœªé€£ç·š');
                updateStatus('âŒ é€£ç·šå·²ä¸­æ–·ï¼Œæ­£åœ¨é‡æ–°é€£ç·š...');
                initWebSocket();
            }
        }

        // å¤„ç†MCPæ¶ˆæ¯
        function handleMCPMessage(data) {
            if (data.method === 'notifications/message') {
                // å¤„ç†AIå›å¤æ¶ˆæ¯
                if (data.params && data.params.content) {
                    const content = data.params.content;
                    if (content.type === 'text') {
                        lastAiMessage = content.text;
                        addMessage(content.text, 'ai');
                        updateStatus('âœ… å·²è¿æ¥åˆ°å°æ™ºAI');
                        
                        // è‡ªåŠ¨è¯­éŸ³æ’­æ”¾
                        if (synthesis) {
                            speakText(content.text);
                        }
                    }
                }
            } else if (data.result) {
                // å¤„ç†å…¶ä»–å“åº”
                console.log('æ”¶åˆ°å“åº”:', data.result);
            } else if (data.error) {
                console.error('MCPé”™è¯¯:', data.error);
                updateStatus('âŒ æœåŠ¡å™¨é”™è¯¯: ' + data.error.message);
            }
        }

        // åˆå§‹åŒ–è¯­éŸ³è¯†åˆ«
        function initSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = currentLanguage;

                recognition.onstart = function() {
                    updateStatus('æ­£åœ¨è†è½...');
                };

                recognition.onresult = function(event) {
                    const transcript = event.results[0][0].transcript;
                    addMessage(transcript, 'user');
                    sendToAI(transcript);
                };

                recognition.onerror = function(event) {
                    updateStatus('èªéŸ³è­˜åˆ¥éŒ¯èª¤: ' + event.error);
                    isRecording = false;
                    updateRecordButton();
                };

                recognition.onend = function() {
                    isRecording = false;
                    updateRecordButton();
                    updateStatus('æº–å‚™å°±ç·’');
                };
            } else {
                updateStatus('ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³è­˜åˆ¥');
            }
        }

        // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©åŒºåŸŸ
        function addMessage(message, sender) {
            const chatArea = document.getElementById('chatArea');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message`;
            messageDiv.textContent = message;
            chatArea.appendChild(messageDiv);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        // å‘é€æ¶ˆæ¯
        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            if (message) {
                addMessage(message, 'user');
                input.value = '';
                sendToAI(message);
            }
        }

        // å‘é€åˆ°AI (çœŸå®MCPè¿æ¥)
        function sendToAI(message) {
            if (!isConnected) {
                updateStatus('âŒ æœªé€£ç·šåˆ°ä¼ºæœå™¨');
                addMessage('æŠ±æ­‰ï¼Œç›®å‰ç„¡æ³•é€£ç·šåˆ°AIä¼ºæœå™¨ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚', 'ai');
                return;
            }

            updateStatus('ğŸ¤” å°æ™ºæ­£åœ¨æ€è€ƒ...');
            
            // å‘é€å¯¹è¯æ¶ˆæ¯åˆ°MCPæœåŠ¡å™¨
            const mcpMessage = {
                jsonrpc: "2.0",
                id: messageId++,
                method: "sampling/createMessage",
                params: {
                    messages: [
                        {
                            role: "user",
                            content: {
                                type: "text",
                                text: message
                            }
                        }
                    ],
                    modelPreferences: {
                        hints: [
                            {
                                name: "claude-3-5-sonnet-20241022"
                            }
                        ],
                        costPriority: 0.5,
                        speedPriority: 0.8,
                        intelligencePriority: 0.9
                    },
                    systemPrompt: `ä½ æ˜¯å°æ™ºï¼Œä¸€å€‹å‹å–„ã€è°æ˜ã€æœ‰è¶£çš„AIåŠ©æ‰‹ã€‚è«‹ç”¨${getLanguageName(currentLanguage)}å›è¦†ç”¨æˆ¶ã€‚å›è¦†è¦ç°¡æ½”æœ‰è¶£ï¼Œå……æ»¿æ´»åŠ›ã€‚`,
                    includeContext: "thisConversation",
                    temperature: 0.7,
                    maxTokens: 1000
                }
            };

            sendMCPMessage(mcpMessage);
        }

        // è·å–è¯­è¨€åç§°
        function getLanguageName(langCode) {
            const langMap = {
                'zh-TW': 'ç¹é«”ä¸­æ–‡',
                'zh-CN': 'ç°¡é«”ä¸­æ–‡',
                'en-US': 'English',
                'ja-JP': 'æ—¥æœ¬èª',
                'ko-KR': 'í•œêµ­ì–´'
            };
            return langMap[langCode] || 'ç¹é«”ä¸­æ–‡';
        }

        // æ–‡æœ¬è½¬è¯­éŸ³
        function speakText(text) {
            if (synthesis) {
                synthesis.cancel(); // åœæ­¢å½“å‰æ’­æ”¾
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = currentLanguage;
                utterance.rate = 0.9;
                utterance.pitch = 1.1;
                synthesis.speak(utterance);
            }
        }

        // æ’­æ”¾æœ€åä¸€æ¡AIæ¶ˆæ¯
        function speakLastMessage() {
            if (lastAiMessage) {
                speakText(lastAiMessage);
            }
        }

        // åˆ‡æ¢å½•éŸ³çŠ¶æ€
        function toggleRecording() {
            if (!recognition) {
                updateStatus('èªéŸ³è­˜åˆ¥ä¸å¯ç”¨');
                return;
            }

            if (isRecording) {
                recognition.stop();
            } else {
                recognition.start();
                isRecording = true;
            }
            updateRecordButton();
        }

        // æ›´æ–°å½•éŸ³æŒ‰é’®çŠ¶æ€
        function updateRecordButton() {
            const btn = document.getElementById('recordBtn');
            if (isRecording) {
                btn.classList.add('recording');
                btn.textContent = 'â¹ï¸';
            } else {
                btn.classList.remove('recording');
                btn.textContent = 'ğŸ¤';
            }
        }

        // æ›´æ”¹è¯­è¨€
        function changeLanguage() {
            currentLanguage = document.getElementById('languageSelect').value;
            if (recognition) {
                recognition.lang = currentLanguage;
            }
            
            const welcomeMessages = {
                'zh-TW': 'ğŸ‘‹ æ‚¨å¥½ï¼æˆ‘æ˜¯å°æ™ºï¼Œæ‚¨çš„AIèŠå¤©å¤¥ä¼´<br>å¯ä»¥å’Œæˆ‘èªéŸ³å°è©±æˆ–æ–‡å­—èŠå¤©å–”ï¼',
                'zh-CN': 'ğŸ‘‹ ä½ å¥½ï¼æˆ‘æ˜¯å°æ™ºï¼Œä½ çš„AIèŠå¤©ä¼™ä¼´<br>å¯ä»¥å’Œæˆ‘è¯­éŸ³å¯¹è¯æˆ–æ–‡å­—èŠå¤©å“¦ï¼',
                'en-US': 'ğŸ‘‹ Hello! I\'m Xiaozhi, your AI chat companion<br>You can talk to me by voice or text!',
                'ja-JP': 'ğŸ‘‹ ã“ã‚“ã«ã¡ã¯ï¼ç§ã¯å°æ™ºã€ã‚ãªãŸã®AIãƒãƒ£ãƒƒãƒˆãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ã§ã™<br>éŸ³å£°ã‚„ãƒ†ã‚­ã‚¹ãƒˆã§è©±ã—ã‹ã‘ã¦ãã ã•ã„ï¼',
                'ko-KR': 'ğŸ‘‹ ì•ˆë…•í•˜ì„¸ìš”! ì €ëŠ” ìƒ¤ì˜¤ì§€, ë‹¹ì‹ ì˜ AI ì±„íŒ… ë™ë°˜ìì…ë‹ˆë‹¤<br>ìŒì„±ì´ë‚˜ í…ìŠ¤íŠ¸ë¡œ ëŒ€í™”í•  ìˆ˜ ìˆì–´ìš”!'
            };
            
            updateStatus(currentLanguage === 'zh-TW' ? 'èªè¨€å·²åˆ‡æ›' : 'Language changed');
        }

        // é‡æ–°è¿æ¥
        function reconnect() {
            if (websocket) {
                websocket.close();
            }
            isConnected = false;
            
            // é‡æ–°è·å–endpointä»¥æ£€æŸ¥tokenæ›´æ–°
            const newEndpoint = getMCPEndpoint();
            if (!newEndpoint) {
                updateStatus('âŒ éœ€è¦é…ç½®Token');
                addMessage('è«‹å…ˆé…ç½®Tokenæ‰èƒ½é€£ç·šã€‚', 'ai');
                return;
            }
            
            updateStatus('æ­£åœ¨é‡æ–°é€£ç·š...');
            setTimeout(() => {
                initWebSocket();
            }, 1000);
        }

        // æ›´æ–°çŠ¶æ€
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
            
            // æ›´æ–°è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨
            const indicator = document.getElementById('statusIndicator');
            const connectionText = document.getElementById('connectionText');
            
            if (isConnected) {
                indicator.classList.add('connected');
                connectionText.textContent = 'å·²é€£ç·šåˆ°å°æ™ºAI';
            } else if (!getMCPEndpoint()) {
                indicator.classList.remove('connected');
                connectionText.textContent = 'éœ€è¦é…ç½®Token';
            } else {
                indicator.classList.remove('connected');
                connectionText.textContent = 'é€£ç·šä¸­...';
            }
        }

        // è¾“å…¥æ¡†å›è½¦äº‹ä»¶
        document.getElementById('messageInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // åˆå§‹åŒ–
        initSpeechRecognition();
        initWebSocket();
        updateStatus('æ­£åœ¨åˆå§‹åŒ–...');
    </script>
</body>
</html>
